7a8
> #include <signal.h>
27,31c28,36
< typedef struct commands {
<     char * command;
<     int argc;
<     char ** argv;
< }commands;
---
> user_t initshell(user_t user);
> void exterminate(int * pid);
> int dalek(int pid);
> int background(char ** args, int * pidarr, int i);
> char ** inithistory(FILE * fp, char ** history);
> int addhistory(char * input, FILE * fp, char ** history, int i);
> char ** parser(char * input);
> int start(char ** args);
> void help();
34a40
>     // Finangling this took me forever. But at least it looks nice.
45a52
>     // Get all system information for shell prompt
52a60
>     // Just checking for debugging purposes.
56a65
>     // Clear the shell afterwards.
61a71,76
> char ** inithistory(FILE * fp, char ** history)
> {
>     char * buffer = NULL;
>     size_t len = 0;
>     int i = 0;
>     int size = MAXLETTERS;
63,64c78
< commands * addtohistory(char * buffer, char ** args, FILE * fp, 
<                         commands * history, int i) {
---
>     history = (char **)malloc(MAXLETTERS * sizeof(char *));
66,68c80,89
<     if(!fprintf(fp, "%s", buffer)) {
<             fprintf(stderr, "mysh: error saving command to history.\n");
<             return history;
---
>     while (getline(&buffer, &len, fp) != -1) {
>         history[i] = malloc(sizeof(buffer));
>         strcpy(history[i], buffer);
>         
>         if (i >= size)
>         {
>             size += MAXLETTERS;
>             history = (char **)realloc(history, size * sizeof(char **));
>         }
>         i++;     
71,75c92,94
<     history[i].argc = sizeof(args) / sizeof(args[0]) - 1;
<     // printf("%d\n", history->argc);   
<     history[i].argv = args;
<     history[i].command = buffer;
< 
---
>     i++;
>     // Cleaning up.
>     free(buffer);
79c98
< FILE * readhistory(char ** argv, FILE * fp)
---
> int addhistory(char * input, FILE * fp, char ** history, int i)
81,84c100,103
<     char * buffer;
<     size_t len = 0;
<     if (strcmp(argv[1], "-c") == 0)
<         freopen("history.txt", "w+", fp);
---
>     int size = sizeof(history) / sizeof(char **);
>     if (i > size)
>         size += MAXLETTERS;
>         history = realloc(history[i], size * sizeof(char **));
86,88c105,107
<     else
<         while (getline(&buffer, &len, fp) != -1)
<             fprintf(stdout, "%s\n", buffer);
---
>     strcpy(history[i], input);
>     fprintf(fp, "%s", input);
>     i++;
90,91c109
<     free(buffer);
<     return fp;
---
>     return i;
111c129
<     size_t size = 0, last = 0;
---
>     size_t size = 0;
113,114c131
< 
<     do
---
>     if (getline(&buffer, &size, stdin) == -1)
116,118c133,135
<         size += MAXLETTERS;
<         
<         if (!(buffer = realloc(buffer, size + 1)))
---
>         if(feof(stdin))
>            exit(0); 
>         else
120,121c137,138
<             fprintf(stderr, "mysh: memory allocation error while reading user input\n");
<             return 0;    
---
>             fprintf(stderr, "mysh : error reading from line\n");
>             exit(-1);
123,127c140
< 
<         fgets(buffer + last, size, stdin);
<         last = strlen(buffer) - 1;
< 
<     } while(!feof(stdin) && buffer[last] != '\n');
---
>     }
131a145,152
> char ** replay(char ** args, char ** history)
> {
>     // Pretty easy oneliner. So long as you don't accidentally choose to replay a replay. 
>     // It should be that replay isn't stored in the history command but choosing to go into an 
>     // infinite loop isn't any of my business.
>     return parser(history[(int)args[1]]);
> }
> 
136c157,158
<     char * token = strtok(input, "\t\r\n\a");
---
>     // Deal with all cases of delimiters: tabs, newlines, spaces, bell spaces, 
>     char * token = strtok(input, "\t\r\n\a ");
151c173
<         token = strtok(NULL, "\t\r\n\a");
---
>         token = strtok(NULL, "\t\r\n\a ");
158,181d179
< int launch(user_t user, char ** args)
< {
<     pid_t pid, wpid;
<     int status;
<     pid = fork();
<     
<     if (pid <= 0) {
<         if (execv(user.dir, args) < 0) {
<             fprintf(stderr, "mysh: error executing program\n");
<             return -1;
<         }
<         fprintf(stderr, "mysh: error forking program\n");
<         return -1;
<     }
< 
<     else {
<         do {
<             wpid = waitpid(pid, &status, WUNTRACED);
<         } while (!WIFEXITED(status) && !WIFSIGNALED(status));
<     }
< 
<     return 1;
< }
< 
191a190,233
> user_t cd(char ** args, user_t user)
> {
>     // Shouldn't be able to cd to more than one place at a time.
>     if (args[2] != NULL)
>     {
>         fprintf(stderr, "mysh: too many arguments\n");
>         return user;
>     }
> 
>     // Nothing to cd to!
>     if (args[1] == NULL)
>     {
>         fprintf(stderr, "mysh: argument required\n");
>         return user;
>     }
> 
>     else
>     {
>         if (!strcmp(args[1], "~"))
>         {
>             char buf[PATH_MAX] = "/home/";
>             strcat(buf, user.username);
>             strncpy(args[1], buf, PATH_MAX);
>         }
> 
>         char buffer[PATH_MAX];
>         char * dir = realpath(args[1], buffer);
>         if (dir) {
>             printf("%s\n", buffer);
>             strcpy(user.dir, buffer);
>         }
> 
>         else
>             // Unfortunately, you get a "no directory found" as realpath 
>             // only ever searches in the directory of the currently running 
>             // program, which is infuriating. So any relative pathing would 
>             // be pointless, as you can only relpath around the directory this
>             // program is issued from.
>             fprintf(stderr, "mysh: no directory found\n");
>     }
> 
>     return user;
> }
> 
194,195c236,244
<     char cwd[MAXLETTERS];
<     strcpy(cwd, user.dir);
---
>     char * dirprompt; 
>     char home[PATH_MAX];
> 
>     strcpy(home, "/home/");
>     strcat(home, user.username);
>     // change home to ~
>     if (!strcmp(user.dir, home))
>         dirprompt = strdup("~");
>     
197,198c246,249
<     char * dirprompt = strrchr(user.dir, '/');
<     dirprompt++;
---
>     else {
>         dirprompt = strrchr(user.dir, '/');
>         dirprompt++;
>     }
201a253,254
> 
>     
205,207c258,268
< int cd(char ** args, user_t user)
< {
<     if (args[2] != NULL)
---
> int start(char ** args) {
>     // Fork the current process, then change the child process to the 
>     // program you want to run. Yay.
>     pid_t pid, wpid;
>     int status = 0;
>     char env[PATH_MAX] = "/usr/bin/";
>     
>     if (strstr(args[0], "/"))
>         strcat(env, args[0]);
>     
>     if ((pid = fork()) <= 0)
209,210c270,272
<         fprintf(stderr, "mysh: too many arguments\n");
<         return 0;
---
>         if (execvp(args[0], args) == -1)
>             fprintf(stderr, "mysh : error forking process\n");
>         return -1;  
211a274,276
>     
>     else
>         waitpid(pid, &status, 0);
213,217c278,279
<     if (args[1] == NULL)
<     {
<         fprintf(stderr, "mysh: argument required\n");
<         return 0;
<     }
---
>     return 1;
> }
219c281,296
<     else
---
> int background(char ** args, int * pidarr, int i)
> {
>     // Background should be the same as start, except we don't wait. 
>     // I don't really know why, but when executed the function still shows up
>     // on stdout rather than through  
>     pid_t pid;
>     pid = fork();
>     // check if already a daemon
>     if(kill(pid, 0)){
>         fprintf(stderr, "mysh : process with pid %d already exists\n", pid);
>         return -1;
>     }
>     if (pid < 0) 
>         fprintf(stderr, "mysh : error forking process\n");
>     
>     if (pid == 0)
221,225c298,300
<         char buffer[MAXLETTERS];
<         DIR * dir;
<         if (dir = opendir(args[1])) {
<             strcpy(buffer, args[1]);
<             closedir(dir);
---
>         if (execvp(args[0], args) == -1){
>             fprintf(stderr, "mysh : error forking process\n");
>             return -1;
228,229c303,334
<         else {
<             fprintf(stderr, "mysh: no directory found");
---
> 
>     }   
>         // Add pid to the pid table.
>         pidarr[i] = pid;
>         // Increment the history counter.
>         i++;
>     printf("+ background pid: %i, command: %s\n", pid, args[0]);
>     return i;
> }
> 
> FILE * readhistory(char ** argv, char ** history, FILE * fp)
> {
>     // This checks three things: if the file should be cleared
>     // If the user checks a specific history number
>     // And if the user doesn't put anything, to just show the whole history.
> 
>     char * buffer = malloc(MAXLETTERS * sizeof(char));
>     int size = sizeof(history) / sizeof(char **);
>     size_t len = 0;
>     
>     // reopen file
>     if (!strcmp(argv[1], "-c"))
>         // I checked to make sure this doesn't lose any of the history commands.
>         // It shouldn't, but sometimes it did.
>         freopen("history.txt", "w+", fp);
>     
>     else if (argv[1] != NULL)
>         fprintf(stdout, "%s: %s\n", argv[1], history[size - (int)argv[1]]);
> 
>     else if (argv[1] == NULL) {
>         for (int i = size; i > 0; i--)
>             fprintf(stdout, "%d: %s\n", size - i, history[i]);
232c337,348
<         strrchr(buffer, '/');
---
>     free(buffer);
>     return fp;
> }
> 
> int dalek(int pid) {
>     // There should be some sort of logic to check if the pid is negative so 
>     // you don't do kill -1.
> 
>     if (kill(pid, SIGKILL) == -1)
>     {
>         fprintf(stderr, "mysh: Error killing process.\n");
>         return -1;
233a350,353
>     
>     // Yay! We killed a process.
>     fprintf(stderr, " + killed %d\n", pid);
> 
237c357
< int bye(FILE * fp, user_t user, commands * history)
---
> void exterminate(int * pid)
239,242c359,368
<     fclose(fp);
<     free(history);
<     clear();
<     exit(0);
---
>     // This *should* work. 
>     int size = sizeof(pid) / sizeof(int);
>     // Go through all pids and delete them, 
>     for (int i = 0; i < size; i++)
>     {
>         if (pid[i] > 0)
>             dalek(pid[i]);
>     }
> 
>     return;
245,249c371,374
< int main()
< {
<     FILE *fp = fopen("history.txt", "a+");
<     char ** argv;
<     char * input, * pipe = NULL;
---
> int main() {
>     FILE * fp = fopen("history.txt", "a+");
>     char ** argv, ** tmp, ** history = NULL;
>     char * input, * ptr;
252,253d376
<     commands * history = malloc(MAXLETTERS * sizeof(commands));
< 
255c378,379
<     fprintf(stdout, "%s\n", user.dir);
---
>     history = inithistory(fp, history);
>     int * pid = malloc(MAX_INPUT * sizeof(int));
260d383
<         fprintf(stdout, "%s\n", user.dir);
261a385
>         addhistory(input, fp, history, i);
264d387
<         history = addtohistory(input, argv, fp, history, i);
266c389,392
<         // fprintf(stdout, YELLOW "%s" RESET, argv[0]);
---
>         // run this one first, so that you can run the other 
>         // commands afterwards
>         if (!strcmp(argv[0], "replay"))
>             argv = replay(argv, history);
268,276c394,402
<         if (!strcmp(argv[0], "start"))
<             if (launch(user, argv) < 0)
<                 continue;
<         
<         if (!strcmp(argv[0], "whereami"))
<             cwd(user);
<             
<         if (!strcmp(argv[0], "movetodir"))
<             cd(argv, user);    
---
>         // process whatever is in the buffer     
>         else if (!strcmp(argv[0], "byebye"))
>             break;
> 
>         else if (!strcmp(argv[0], "whereami"))
>             cwd(user);  
> 
>         else if (!strcmp(argv[0], "movetodir"))
>             user = cd(argv, user);    
278,279c404,411
<         if (!strcmp(argv[0], "history"))
<             fp = readhistory(argv, fp);
---
>         else if (!strcmp(argv[0], "start"))
>         {
>             // I moved the pointer of the struct so that it wouldn't be 
>             // included in the function call.
>             tmp = argv;
>             tmp++;
>             start(tmp);
>         }
281c413
<         if (!strcmp(argv[0], "byebye"))
---
>         else if (!strcmp(argv[0], "dalek"))
283,284c415,424
<             bye(fp, user, history);
<             break;
---
>             if (argv[1] == NULL)
>                 fprintf(stderr, "argument required for dalek\n");
>             dalek(strtol(argv[1], &ptr, 10));
>         }
>         
>         else if (!strcmp(argv[0], "background"))
>         {
>             tmp = argv;
>             tmp++;
>             background(tmp, pid, i);
286c426,431
<         // process whatever is in the buffer            
---
> 
>         else if (!strcmp(argv[0], "history"))
>             fp = readhistory(argv, history, fp);
> 
>         free(input);
>         free(argv);
288c433,438
<     
---
> 
>     fclose(fp);
>     clear();
>     exit(0);
>     free(pid);
> 
